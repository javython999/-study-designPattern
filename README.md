# 디자인 패턴
# 생성 패턴
## 싱글톤(Singleton)
인스턴스를 오직 한개만 제공하는 클래스
***
## 팩토리(Factory method)
구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.

* 팩토리 메소드 패턴의 장/단점
  * 장점
    * 기존의 코드를 변경하지 않고 새로운 기능을 확장시킬 수 있다.
  * 단점
    * 각각의 기능을 나누다 보니 클래스의 수(코드의 량)가 늘어나게 된다.
* "확장에 열려있고 변경에 닫혀있는 객체 지향 원칙"
  * 확장에 열려있다.
    * 객체의 기능을 자유롭게 추가할 수 있어야 한다.
  * 변경에 닫혀있다.
    * 기존의 코드를 변경하지 않고 새로운 기능을 확장할 수 있다.
* 자바 8에 추가된 default 메소드
  * 추상 클래스에 default 메소드를 구현해두면 추상 클래스를 구현한 클래스는 별도의 구현 없이 바로 default를 사용할 수 있게 된다.
***
## 추상 팩토리(Abstract Factory)
추상 팩토리 패턴은 연관성 있는 객체 군이 여러개 있을 경우 이들을 묶어 추상화하고,
어떤 구체적인 상황이 주어지면 팩토리 객체에서 집합으로 묶은 객체 군을 구현화 하는 생성 패턴이다.

클라이언트는 특정 객체를 사용할 때 팩토리 클래스만을 참조하여 특정 객체에 대한 구현부를 감추어 역할과 구현을 분리시킬 수 있다.
* 추상 팩토리 패턴의 장/단점
  * 장점
    * 객체 생성 코드를 클라이언트와 분리해 결합도를 낮춘다.
    * 제품 군을 쉽게 대체할 수 있다.
    * 단일 책임 원칙 준수
    * 개방/폐쇄 원칙 준수
  * 단점
    * 각 구현체 마다 팩토리 객체들을 구현해주어야 하기에 코드량이 증가한다.
    * 추상 팩토리에 수정이 생기면 모든 팩토리에 대한 수정이 필요해진다.
***
## 빌더(Builder)
복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성패턴이다.
생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 마지막에 통합 빌드해서 객체를 생성성하는 방식이다.

* 빌더 패턴의 장/단점
  * 장점
    * 객체 생성 과정을 일관된 프로세스로 표현
    * 필수 멤버와 선택적 멤버를 분리가능
    * 객체 생성 단계를 지연할 수 있음
  * 단점
    * 코드 복잡성 증가: 기존 생성자로 생성하던 방식에 비해 빌더 또는 디렉터까지 이용하게 되면서 복잡해진다.
    * 생성자 보다는 성능은 떨어진다.
***
## 프로토타입(Prototype)
기존 인스턴스를 복제하여 새로운 인스턴스를 만드는 방법
복제 기능을 갖추고 있는 기존 인스턴스를 프로토타입으로 사용해 새 인스턴스를 만들 수 있다.

* 프로토타입 패턴의 장/단점
  * 장점
    * 복잡한 객체를 만드는 과정을 숨길 수 있다.
    * 기존 객체를 복제하는 과정이 새 인스턴스를 만드는 것보다 비용(시간 또는 메모리)적인 면에서 효율적일 수 있다.
    * 추상적인 타입을 리턴할 수 있다.
  * 단점
    * 복제한 객체를 만드는 과정 자체가 복잡할 수 있다.(특히 순환 참조가 있는 경우)
***
# 구조 패턴
## 어댑터(Adapter)
기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴

* 어댑터 패턴의 장/단점
  * 장점
    * 기존 코드를 변경하지 않고도 원하는 인터페이스 구현체를 만들어 재사용할 수 있다.(개방-폐쇄 원칙)
    * 기존 코드가 하던 일과 특정 인터페이스를 구현체로 변환하는 작업을 각기 다른 클래스로 분리하여 관리할 수 있다.(단일책임원칙)
  * 단점
    * 새 클래스가 생겨 복잡도가 증가할 수 있다. 경우에 따라서 기존 코드가 해당 인터페이스를 구현하도록 수정하는것이 좋은 선택이 될 수도 있다.
***
## 브릿지(Bridge)
추상적인 것과 구체적인 것을 분리하여 연결하는 패턴


* 브릿지 패턴의 장/단점
  * 장점
    * 추상적인 코드를 구체적인 코드 변경 없이도 독립적으로 확장할 수 있다.
    * 추상적인 코드와 구체적인 코드를 분리할 수 있다.
  * 단점
    * 계층 구조가 늘어나 복잡도가 증가할 수 있다.
***
## 컴포짓(Composite)
그룹 전체와 개별 객체를 동일하게 처리할 수 있는 패턴
클라이언트 입장에서는 '전체'나 '부분'이나 모두 동일한 컴포넌트로 인식할 수 있는 계층 구조를 만든다.(Part-Whole Hieracrhy)

* 컴포짓 패턴의 장/단점
  * 장점
    * 복잡한 트리 구조를 편리하게 사용할 수 있다.
    * 다형성과 재귀를 활용할 수 있다.
    * 클라이언트 코드를 변경하지 않고 새로운 엘리먼트 타입을 추가할 수 있다.
  * 단점
    * 트리를 만들어야 하기 때문에 (공통된 인터페이스를 정의 해야 하기 때문에) 지나치게 일반화 해야하는 경우도 생길 수 있다.
***
## 데코레이터(Decorator)
기존 코드를 변경하지 않고 부가 기능을 추가하는 패턴
상속이 아닌 위임을 사용해서 보다 유연하게(런타임) 부가 기능을 추가하는 것도 가능하다.  

* 데코레이터 패턴의 장/단점
  * 장점
    * 새로운 클래스를 만들지 않고 기존 기능을 조합할 수 있다.
    * 컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있다.
  * 단점
    * 데코레이터를 조합하는 코드가 복잡할 수 있다.
***
## 퍼사드(Facade)
복잡한 서브 시스템 의존성을 최소화하는 방법

* 퍼사드 패턴의 장/단점
  * 장점
    * 서브 시스템에 대한 의존성을 한곳으로 모을 수 있다.
  * 단점
    * 퍼사드 클래스가 서프 시스템에 대한 모든 의존성을 가지게 된다.
***
## 플라이웨이트(Flyweight)
객체를 가볍게 만들어 메모리 사용을 줄이는 패턴이다. 자주 변하는 속성과 변하지 않는 속성을 분리하고 재사용하여 메모리 사용을 줄일 수 있다.

* 플라이웨이트 패턴의 장/단점
  * 장점
    * 애플리케이션에서 사용하는 메모리를 줄일 수 있다.
  * 단점
    * 코드의 복잡도가 증가한다.
***
## 프록시(Proxy)
특정 객체에 대한 접근을 제어하거나 기능을 추가할 수 있는 패턴.
초기화 지연, 접근제어, 로깅, 캐싱 등 다양하게 응용해 사용할 수 있다.

* 프록시 패턴의 장/단점
  * 장점
    * 기존 코드를 변경하지 않고 새로운 기능을 추가 할 수 있다.
    * 기존 코드가 해야하는 일만 유지할 수 있다.
    * 기능 추가 및 초기화 지연 등으로 다양하게 활용할 수 있다.
  * 단점
    * 코드의 복잡도가 증가한다.
***
# 행동 패턴
## 책임 연쇄(Chain Of Responsibilities)
요청을 보내는 쪽(sender)과 요청을 처리하는 쪽(reciever)을 분리하는 패턴

* 책임 연쇄 패턴의 장/단점
  * 장점
    * 다양한 형태의 체인을 만들 수 있다.
    * 단일 책임 원칙을 지킬 수 있게 된다.
  * 단점
    * 디버깅이 번거러워 진다.
***
## 커맨드(Command)
요청을 캡슐화 하여 호출자(invoker)와 수신자(receiver)를 분리하는 패턴.
요청을 처리하는 방법이 바뀌더라도, 호출자의 코드는 변경되지 않는다.

* 커맨드 패턴의 장/단점
  * 장점
    * 기존 코드를 변경하지 않고 새로운 커맨드를 만들 수 있다.
    * 수신자의 코드가 변경되어도 호출자의 코드는 변경되지 않는다.
    * 커맨드 객체를 로깅, DB에 저장, 네트워크 전송 하는 등 다양한 방법으로 활용할 수도 있다.
  * 단점
    * 코드가 복잡하고 클래스가 많아진다.
***